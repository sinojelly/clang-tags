#+TITLE: clang-tags -- User Manual
#+SETUPFILE: setup.org
#+HTML_HEAD: <style type="text/css">
#+HTML_HEAD:   #text-1 pre.src { float: left; margin-right: 3em }
#+HTML_HEAD:   #sec-1-1 { clear: both; }
#+HTML_HEAD: </style>

=clang-tags= is a C / C++ source code indexing tool. Unlike many other indexing tools, =clang-tags=
relies on the [[http://clang.llvm.org][clang]] compiler (via the libclang interface) to analyse and index the source code base.


* Introduction

  Let us consider the following C++ code:

  #+include: "@PROJECT_SOURCE_DIR@/tests/src/main.cxx" src c++ -n -r

  A few difficulties can be found in this file, making indexing difficult without the help of a
  full-fledged C++ compiler:

  1. Depending on the =DEBUG= preprocessor macro, the definition of the function =debug= might be found
     at line [[(debug1)]] or [[(debug2)]].

  2. The =display= identifier is used in several places to mean widely different things (for example
     at lines [[(display1)]] and [[(display2)]]). Context information is necessary to disambiguate uses of
     the same identifier.

  3. Even when =display= refers to the method of template class =MyClass<>=, a precise knowledge of the
     complex C++ template specialization rules is required to associate [[(display2)][a.display()]] with
     [[(defDisplayT)][MyClass<T>::display()]] and [[(display3)][b.display()]] with [[(defDisplayInt)][MyClass<int>::display()]].

  4. Some functions such as constructors or operators can be called without explicitly appearing in
     the code. For example, the [[(defCtor)][MyClass::MyClass()]] constructor is called at line [[(ctor)]].


  On the other hand, using a C++ compiler such as =clang= to parse this code and generate an AST
  requires information about the project configuration and its build environment:

  1. The =config.h= file could be automatically generated by =autoconf= or =CMake= and reside in a
     completely different directory than other source files. The compiler will typically need to be
     provided with =-I= command-line arguments to know where to find header files.

  2. The =DEBUG= macro could well be defined by the compilation command line (typically using a =-D=
     switch).

  A compiler-based indexing tool thus needs to be aware of the full compilation commands which are
  used to build the project, including for each source file:
  - the full list of command-line switches,
  - the directory from which the file is compiled.

  Such information, which we will refer to as a "compilation database" in the following, is usually
  found in the build system configuration, which can take a wide variety of forms: hand-crafted
  =Makefile=, =autotools= project, =CMake= project, /etc./


** Features

   =clang-tags= aims at providing the following features:
   1. generate a compilation database in a build-system-agnostic way,
   2. index the sources of the project,
   3. use this index to provide access to IDE-like features from a command-line
      interface :
      - search for symbol definitions in the source code,
      - search for symbol uses in the source code,
      - auto-complete partially entered code,
   4. integrate these features into Emacs.


** First steps for the impatient
    
   All details are explained later, but the [[file:quickStart.org][quick start guide]] provides a few
   steps to get you started if you are too impatient to read.


** Important notions -- Terminology

   The following terms are used throughout this guide:

   - Translation Unit ::
        A set of source code which is compiled together. Ordinarily, a translation units consists in
        a preprocessed source file, in which all header files have been included, macros have been
        expanded, and so on. In clang-tags a translation unit is identified by the set of
        command-line arguments which would be needed to compile it into an object file.

   - Definition       ::
        The place in the source code where a symbol is declared and/or defined. For each translation
        unit, a given symbol only has one definition location. However, different definition
        locations can be found for the same symbol across all translation units.  For example, the
        definition of local variable =a= in function =main= of =main.cxx= appears at line [[(ctor)]].

   - Reference        ::
        Each occurrence of a symbol name in the source code is seen as a reference to its
        definition. For example, the symbol =a= in expression =a.display()= on line [[(display2)]] is a
        reference to the definition at line [[(ctor)]].

   - Spelling         :: 
        In clang terminology, the name of a symbol as it appears in the source code is referred to
        as its spelling. For example, the spelling of the symbol defined at line [[(ctor)]] is the
        string "a".

   - Unified Symbol Resolution (USR) :: 
        A symbol can not be identified by its spelling only: context information is needed to
        disambiguate uses of the same spelling in different scopes. In order to uniquely identify a
        symbol across all translation units in a project, clang defines Unified Symbol
        Resolutions. For example the USR of the =display= symbol referred to on line [[(display2)]] is
        =c:@S@MyClass>#d@F@display#= whereas line [[(display3)]] refers to the symbol with USR
        =c:@S@MyClass>#I@F@display#=


* Command-line interface

** Creating the compilation database

   =clang-tags= uses a [[http://clang.llvm.org/docs/JSONCompilationDatabase.html][JSON compilation database]] to get the information needed to correctly build the
   project: compile directories and command-line switches. There are different ways to collect this
   information.

*** From a =CMake= project

    =CMake= (since version 2.8.5) supports the generation of a compilation database with the option
    =CMAKE_EXPORT_COMPILE_COMMANDS=. For a =CMake=-managed project, creating the compilation database is
    thus as simple as:
    #+begin_src sh
      cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ../src
    #+end_src


*** Tracing the standard build process

    For non =CMake=-managed projects, there is no "free" way to build the compilation database. One
    way to get the necessary information consists in inspecting the build process as a black box
    using [[http://linux.die.net/man/1/strace][=strace(1)=]] (also see [[https://github.com/rizsotto/Bear][=Bear=]] for a tool using =LD_PRELOAD= to implement the same kind of
    strategy).

    Such a method is inherently independent of the build process: Makefile (possibly
    autotools-generated), shell or python script, ... However, the downside with this approach is
    that =make= and other build systems traditionally only rebuild what's needed, and the generated
    compilation database can thus be incomplete. Such methods also depend on platform-specific
    features to inspect the build process.

    #+include: "@PROJECT_BINARY_DIR@/tests/trace-help.out" src fundamental

    - Example usage ::
      #+include: "@PROJECT_SOURCE_DIR@/tests/ct-trace" src sh :lines "3-"
      #+include: "@PROJECT_BINARY_DIR@/tests/ct-trace.out" src fundamental


*** Scanning the sources directory

    For relatively simple projects, it can be sufficient to simply scan the top sources directory to
    find all =*.c= or =*.cxx= files, and additionally provide =clang-tags= with a set of command-line
    arguments necessary for =clang= to parse these files.

    #+include: "@PROJECT_BINARY_DIR@/tests/scan-help.out" src fundamental

    - Example usage ::
      #+begin_src sh
        clang-tags scan ../src -- -I.
      #+end_src
      # #+include: "@PROJECT_SOURCE_DIR@/tests/ct-scan" src sh :lines "3-"
      # #+include: "@PROJECT_BINARY_DIR@/tests/ct-scan.out" src fundamental


** Loading the compilation commands

*** From a compilation database

    This command loads a previously created compilation database into the server.

    An optional argument =--emacs-conf= allows generating a suitable =.dir-local.el=
    emacs configuration file in the sources directory.

    #+include: "@PROJECT_BINARY_DIR@/tests/load-help.out" src fundamental

    - Example usage ::
      #+include: "@PROJECT_SOURCE_DIR@/tests/ct-load" src sh :lines "3-"
      #+include: "@PROJECT_BINARY_DIR@/tests/ct-load.out" src fundamental
    

*** Manually

    It is possible (although impractical) to manually load a compilation command
    into the server.

    #+include: "@PROJECT_BINARY_DIR@/tests/add-help.out" src fundamental
    
    - Example usage ::
      #+BEGIN_SRC sh
        clang-tags add -- g++ -c -o main.o main.cxx
      #+END_SRC


*** Using a fake compiler

    Another common way of getting compilation commands consists in interposing
    fake compilers between the buid process and the real compiler.

    #+include: "@PROJECT_BINARY_DIR@/tests/fake-compiler-help.out" src fundamental

    - Example usage ::
  
      - for a simple project :: simply ensure the whole project will be rebuilt
           and use =clang-tags fake-compiler= to rebuild it.
  
        #+BEGIN_SRC sh
          # Ensure the whole project will be rebuilt
          make clean
          # Rebuild the project using fake compilers
          clang-tags fake-compiler -- make
        #+END_SRC
    
      - for =autotools=- or =CMake=-managed projects :: =autoconf= and =CMake=
           might remember the full path to the compilers, as determined during at
           configure time. It is thus needed to reconfigure the project using
           =clang-tags fake-compiler=:
  
        #+BEGIN_SRC sh
          clang-tags fake-compiler -- cmake ../src
        #+END_SRC


** Indexing the source files

   The server monitors all known source files on the filesystem and updates the
   index as necessary in the background. You should therefore never need to
   bother about keeping the index up-to-date.

   You may however want to make sure the server is finished updating the index
   before querying it.

   #+include: "@PROJECT_BINARY_DIR@/tests/index-help.out" src fundamental
   
   - Example usage ::
     #+include: "@PROJECT_SOURCE_DIR@/tests/ct-index" src sh :lines "3-"
     #+include: "@PROJECT_BINARY_DIR@/tests/ct-index.out" src fundamental


** Looking for symbols

*** Finding the definition of a symbol

    #+include: "@PROJECT_BINARY_DIR@/tests/find-def-help.out" src fundamental

    - Example usage ::
      #+include: "@PROJECT_SOURCE_DIR@/tests/ct-find-def-i" src sh :lines "3-"
      #+include: "@PROJECT_BINARY_DIR@/tests/ct-find-def-i.out" src ct/find-def-rw


*** Looking for all references to a symbol

    #+include: "@PROJECT_BINARY_DIR@/tests/grep-help.out" src fundamental

    - Example usage ::
      #+include: "@PROJECT_SOURCE_DIR@/tests/ct-grep" src sh :lines "3-"
      #+include: "@PROJECT_BINARY_DIR@/tests/ct-grep.out" src grep-rw


* Emacs user interface

  First, load the package using =M-x load-file RET path/to/clang-tags.el RET=

  With the configuration file generated by the =clang-tags index= command, all
  C/C++ source files in the indexed source directory should automatically
  activate =clang-tags-mode= and have the =ct/default-directory= variable point
  to the index directory.


** Find the definition of the symbol at point

   While in a source buffer, you can use =clang-tags= to find the location of
   the definition of the symbol under point by pressing =M-<dot>=.

   The list of relevant definitions is presented in a buffer, where pressing
   =RET= will take you to the location of the definition.


** Find all uses of a definition in the source base

   After having looked for a definition of the symbol under point, and while in
   the definitions list buffer, press =M-<comma>= to list all uses of the
   current definition in the source code base.

   Results are presented in a =grep-mode= buffer.


* Contributing

  Please do!

  If you make improvements to this code or have suggestions, please do not
  hesitate to fork the repository or submit bug reports on
  [[https://github.com/ffevotte/clang-tags][github]]. The repository's URL is:

    https://github.com/ffevotte/clang-tags.el.git


  A doxygen documentation targeted at developers is available [[file:doxygen/index.html][here]].


* See also

- [[http://clang.llvm.org/doxygen/group__CINDEX.html][libclang API documentation]]
- [[http://llvm.org/devmtg/2010-11/Gregor-libclang.pdf][Doug Gregor's presentation on libclang]]
- [[https://github.com/drothlis/clang-ctags][clang-ctags]]: a similar project
  using libclang to generate =ctags= / =etags= index files.
